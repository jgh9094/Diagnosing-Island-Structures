# Ordered exploitation results

Here we present the results for **best performances** found by each selection scheme replicate on the ordered exploitation diagnostic with our base configurations.
Best performance found refers to the largest average trait score found in a given population.
Note that performance values fall between 0.0 and 100.0.
For our base configuration, we execute migrations every 500 generations and there are 4 islands in a ring topology.
When migrations occur, we swap two individuals (same position on each island) and guarantee that no solution can return to the same island.

## Analysis dependencies

```{r base-ord-libs, message=FALSE}
library(ggplot2)
library(cowplot)
library(dplyr)
library(PupillometryR)
library(sdamr)
```

## Truncation selection

Here we analyze how the different population structures affect truncation selection (size 8) on the ordered exploitation diagnostic.

### Performance over time

```{r base-tru-ord-perf, message=FALSE}
lines = filter(base_over_time, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'TRUNCATION') %>%
  group_by(Structure, Generations) %>%
  dplyr::summarise(
    min = min(pop_fit_max) / DIMENSIONALITY,
    mean = mean(pop_fit_max) / DIMENSIONALITY,
    max = max(pop_fit_max) / DIMENSIONALITY
  )
ggplot(lines, aes(x=Generations, y=mean, group = Structure, fill = Structure, color = Structure, shape = Structure)) +
  geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) +
  geom_line(size = 0.5) +
  geom_point(data = filter(lines, Generations %% 2000 == 0), size = 2.5, stroke = 2.0, alpha = 1.0) +
  scale_y_continuous(
    name="Average trait score",
    limits=c(-1, 101),
    breaks=seq(0,100, 20),
    labels=c("0", "20", "40", "60", "80", "100")
  ) +
  scale_x_continuous(
    name="Generations",
    limits=c(0, 50000),
    breaks=c(0, 10000, 20000, 30000, 40000, 50000),
    labels=c("0e+4", "1e+4", "2e+4", "3e+4", "4e+4", "5e+4")

  ) +
  scale_shape_manual(values=SHAPE)+
  scale_colour_manual(values = cb_palette) +
  scale_fill_manual(values = cb_palette) +
  ggtitle("Performance over time") +
  p_theme
```

### Generation satisfactory solution found

First generation a satisfactory solution is found throughout the 50,000 generations.

```{r base-tru-ord-ssf, warning=FALSE}
filter(base_ssf, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'TRUNCATION') %>%
  ggplot(., aes(x = Structure, y = Generations , color = Structure, fill = Structure, shape = Structure)) +
  geom_flat_violin(position = position_nudge(x = .2, y = 0), scale = 'width', alpha = 0.2) +
  geom_point(position = position_jitter(width = .1), size = 1.5, alpha = 1.0) +
  geom_boxplot(color = 'black', width = .2, outlier.shape = NA, alpha = 0.0) +
  scale_y_continuous(
    name="Generation"
  ) +
  scale_x_discrete(
    name="Structure"
  )+
  scale_shape_manual(values=SHAPE)+
  scale_colour_manual(values = cb_palette, ) +
  scale_fill_manual(values = cb_palette) +
  ggtitle('Generation satisfactory solution found')+
  p_theme + coord_flip()
```

#### Stats

Summary statistics for the first generation a satisfactory solution is found.

```{r base-tru-ord-ssf-sum}
ssf = filter(base_ssf, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'TRUNCATION' & Generations < 60000)
ssf %>%
  group_by(Structure) %>%
  dplyr::summarise(
    count = n(),
    na_cnt = sum(is.na(Generations)),
    min = min(Generations, na.rm = TRUE),
    median = median(Generations, na.rm = TRUE),
    mean = mean(Generations, na.rm = TRUE),
    max = max(Generations, na.rm = TRUE),
    IQR = IQR(Generations, na.rm = TRUE)
  )
```

Kruskal–Wallis test provides evidence of difference among selection schemes.

```{r base-tru-ord-ssf-kru}
kruskal.test(Generations ~ Structure, data = ssf)
```

Results for post-hoc Wilcoxon rank-sum test with a Bonferroni correction.

```{r base-tru-ord-ssf-wil}
pairwise.wilcox.test(x = ssf$Generations, g = ssf$Structure, p.adjust.method = "bonferroni",
                     paired = FALSE, conf.int = FALSE, alternative = 'g')
```



## Tournament selection

Here we analyze how the different population structures affect tournament selection (size 8) on the ordered exploitation diagnostic.

### Performance over time

```{r base-tor-ord-perf, message=FALSE}
lines = filter(base_over_time, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'TOURNAMENT') %>%
  group_by(Structure, Generations) %>%
  dplyr::summarise(
    min = min(pop_fit_max) / DIMENSIONALITY,
    mean = mean(pop_fit_max) / DIMENSIONALITY,
    max = max(pop_fit_max) / DIMENSIONALITY
  )
ggplot(lines, aes(x=Generations, y=mean, group = Structure, fill = Structure, color = Structure, shape = Structure)) +
  geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) +
  geom_line(size = 0.5) +
  geom_point(data = filter(lines, Generations %% 2000 == 0), size = 2.5, stroke = 2.0, alpha = 1.0) +
  scale_y_continuous(
    name="Average trait score",
    limits=c(-1, 101),
    breaks=seq(0,100, 20),
    labels=c("0", "20", "40", "60", "80", "100")
  ) +
  scale_x_continuous(
    name="Generations",
    limits=c(0, 50000),
    breaks=c(0, 10000, 20000, 30000, 40000, 50000),
    labels=c("0e+4", "1e+4", "2e+4", "3e+4", "4e+4", "5e+4")

  ) +
  scale_shape_manual(values=SHAPE)+
  scale_colour_manual(values = cb_palette) +
  scale_fill_manual(values = cb_palette) +
  ggtitle("Performance over time") +
  p_theme
```

### Generation satisfactory solution found

First generation a satisfactory solution is found throughout the 50,000 generations.

```{r base-tor-ord-ssf, warning=FALSE}
filter(base_ssf, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'TOURNAMENT') %>%
  ggplot(., aes(x = Structure, y = Generations , color = Structure, fill = Structure, shape = Structure)) +
  geom_flat_violin(position = position_nudge(x = .2, y = 0), scale = 'width', alpha = 0.2) +
  geom_point(position = position_jitter(width = .1), size = 1.5, alpha = 1.0) +
  geom_boxplot(color = 'black', width = .2, outlier.shape = NA, alpha = 0.0) +
  scale_y_continuous(
    name="Generation"
  ) +
  scale_x_discrete(
    name="Structure"
  )+
  scale_shape_manual(values=SHAPE)+
  scale_colour_manual(values = cb_palette, ) +
  scale_fill_manual(values = cb_palette) +
  ggtitle('Generation satisfactory solution found')+
  p_theme + coord_flip()
```

#### Stats

Summary statistics for the first generation a satisfactory solution is found.

```{r base-tor-ord-ssf-sum}
ssf = filter(base_ssf, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'TOURNAMENT' & Generations < 60000)
ssf %>%
  group_by(Structure) %>%
  dplyr::summarise(
    count = n(),
    na_cnt = sum(is.na(Generations)),
    min = min(Generations, na.rm = TRUE),
    median = median(Generations, na.rm = TRUE),
    mean = mean(Generations, na.rm = TRUE),
    max = max(Generations, na.rm = TRUE),
    IQR = IQR(Generations, na.rm = TRUE)
  )
```

Kruskal–Wallis test provides evidence of difference among selection schemes.

```{r base-tor-ord-ssf-kru}
kruskal.test(Generations ~ Structure, data = ssf)
```

Results for post-hoc Wilcoxon rank-sum test with a Bonferroni correction.

```{r base-tor-ord-ssf-wil}
pairwise.wilcox.test(x = ssf$Generations, g = ssf$Structure, p.adjust.method = "bonferroni",
                     paired = FALSE, conf.int = FALSE, alternative = 'g')
```

## Lexicase selection

Here we analyze how the different population structures affect standard lexicase selection on the ordered exploitation diagnostic.

### Performance over time

```{r base-lex-ord-perf, message=FALSE}
lines = filter(base_over_time, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'LEXICASE') %>%
  group_by(Structure, Generations) %>%
  dplyr::summarise(
    min = min(pop_fit_max) / DIMENSIONALITY,
    mean = mean(pop_fit_max) / DIMENSIONALITY,
    max = max(pop_fit_max) / DIMENSIONALITY
  )
ggplot(lines, aes(x=Generations, y=mean, group = Structure, fill = Structure, color = Structure, shape = Structure)) +
  geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) +
  geom_line(size = 0.5) +
  geom_point(data = filter(lines, Generations %% 2000 == 0), size = 2.5, stroke = 2.0, alpha = 1.0) +
  scale_y_continuous(
    name="Average trait score",
    limits=c(-1, 101),
    breaks=seq(0,100, 20),
    labels=c("0", "20", "40", "60", "80", "100")
  ) +
  scale_x_continuous(
    name="Generations",
    limits=c(0, 50000),
    breaks=c(0, 10000, 20000, 30000, 40000, 50000),
    labels=c("0e+4", "1e+4", "2e+4", "3e+4", "4e+4", "5e+4")

  ) +
  scale_shape_manual(values=SHAPE)+
  scale_colour_manual(values = cb_palette) +
  scale_fill_manual(values = cb_palette) +
  ggtitle("Performance over time") +
  p_theme
```

### Best performance

First generation a satisfactory solution is found throughout the 50,000 generations.

```{r base-lex-ord-per-bst, warning=FALSE}
filter(base_best, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'LEXICASE' & VAR == 'pop_fit_max') %>%
  ggplot(., aes(x = Structure, y = VAL / DIMENSIONALITY, color = Structure, fill = Structure, shape = Structure)) +
  geom_flat_violin(position = position_nudge(x = .2, y = 0), scale = 'width', alpha = 0.2) +
  geom_point(position = position_jitter(width = .1), size = 1.5, alpha = 1.0) +
  geom_boxplot(color = 'black', width = .2, outlier.shape = NA, alpha = 0.0) +
  scale_y_continuous(
    name="Average trait score"
  ) +
  scale_x_discrete(
    name="Structure"
  )+
  scale_shape_manual(values=SHAPE)+
  scale_colour_manual(values = cb_palette, ) +
  scale_fill_manual(values = cb_palette) +
  ggtitle('Best performance')+
  p_theme + coord_flip()
```

#### Stats

Summary statistics for the first generation a satisfactory solution is found.

```{r base-lex-ord-per-bst-sum}
performance = filter(base_best, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'LEXICASE' & VAR == 'pop_fit_max')
performance %>%
  group_by(Structure) %>%
  dplyr::summarise(
    count = n(),
    na_cnt = sum(is.na(VAL)),
    min = min(VAL, na.rm = TRUE) / DIMENSIONALITY,
    median = median(VAL, na.rm = TRUE) / DIMENSIONALITY,
    mean = mean(VAL, na.rm = TRUE) / DIMENSIONALITY,
    max = max(VAL, na.rm = TRUE) / DIMENSIONALITY,
    IQR = IQR(VAL, na.rm = TRUE) / DIMENSIONALITY
  )
```

Kruskal–Wallis test provides evidence of difference among selection schemes.

```{r base-lex-ord-per-bst-kru}
kruskal.test(VAL ~ Structure, data = performance)
```

Results for post-hoc Wilcoxon rank-sum test with a Bonferroni correction.

```{r base-lex-ord-per-bst-wil}
pairwise.wilcox.test(x = performance$VAL, g = performance$Structure, p.adjust.method = "bonferroni",
                     paired = FALSE, conf.int = FALSE, alternative = 'l')
```

### Final performance

First generation a satisfactory solution is found throughout the 50,000 generations.

```{r base-tor-ord-per-end, warning=FALSE}
filter(base_over_time, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'LEXICASE' & Generations == 50000) %>%
  ggplot(., aes(x = Structure, y = pop_fit_max / DIMENSIONALITY, color = Structure, fill = Structure, shape = Structure)) +
  geom_flat_violin(position = position_nudge(x = .2, y = 0), scale = 'width', alpha = 0.2) +
  geom_point(position = position_jitter(width = .1), size = 1.5, alpha = 1.0) +
  geom_boxplot(color = 'black', width = .2, outlier.shape = NA, alpha = 0.0) +
  scale_y_continuous(
    name="Average trait score"
  ) +
  scale_x_discrete(
    name="Structure"
  )+
  scale_shape_manual(values=SHAPE)+
  scale_colour_manual(values = cb_palette, ) +
  scale_fill_manual(values = cb_palette) +
  ggtitle('Final performance')+
  p_theme + coord_flip()
```

#### Stats

Summary statistics for the first generation a satisfactory solution is found.

```{r base-tor-ord-per-end-sum}
performance = filter(base_over_time, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'LEXICASE' & Generations == 50000)
performance %>%
  group_by(Structure) %>%
  dplyr::summarise(
    count = n(),
    na_cnt = sum(is.na(pop_fit_max)),
    min = min(pop_fit_max / DIMENSIONALITY, na.rm = TRUE),
    median = median(pop_fit_max / DIMENSIONALITY, na.rm = TRUE),
    mean = mean(pop_fit_max / DIMENSIONALITY, na.rm = TRUE),
    max = max(pop_fit_max / DIMENSIONALITY, na.rm = TRUE),
    IQR = IQR(pop_fit_max / DIMENSIONALITY, na.rm = TRUE)
  )
```

Kruskal–Wallis test provides evidence of difference among selection schemes.

```{r base-tor-ord-per-end-kru}
kruskal.test(pop_fit_max ~ Structure, data = performance)
```

Results for post-hoc Wilcoxon rank-sum test with a Bonferroni correction.

```{r base-tor-ord-per-end-wil}
pairwise.wilcox.test(x = performance$pop_fit_max, g = performance$Structure, p.adjust.method = "bonferroni",
                     paired = FALSE, conf.int = FALSE, alternative = 'l')
```

### Generation satisfactory solution found

First generation a satisfactory solution is found throughout the 50,000 generations.

```{r base-lex-ord-ssf, warning=FALSE}
lex_fail = filter(base_ssf, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'LEXICASE' & GENERATIONS < Generations)
lex_fail$Generations = 55000
lex_fail$Structure <- factor(lex_fail$Structure, levels = MODEL)

filter(base_ssf, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'LEXICASE'& Generations <= GENERATIONS) %>%
  ggplot(., aes(x = Structure, y = Generations, color = Structure, fill = Structure, shape = Structure)) +
    geom_flat_violin(position = position_nudge(x = .2, y = 0), scale = 'width', alpha = 0.2) +
  geom_point(position = position_jitter(width = .1), size = 1.5, alpha = 1.0) +
  geom_boxplot(color = 'black', width = .2, outlier.shape = NA, alpha = 0.0) +
  geom_point(data = lex_fail, aes(x = Structure, y = Generations, color = Structure, fill = Structure, shape = Structure),position = position_jitter(width = .05), size = 2.5) +
  scale_shape_manual(values=SHAPE)+
  scale_y_continuous(
    name="Generations",
    limits=c(30000, 55000),
    breaks=c(30000, 40000, 50000, 55000),
    labels=c("3e+4", "4e+4", "5e+4", "Fail")
  ) +
  scale_x_discrete(
    name="Structure"
  ) +
  scale_colour_manual(values = cb_palette) +
  scale_fill_manual(values = cb_palette) +
  p_theme + coord_flip()
```

#### Stats

Summary statistics for the first generation a satisfactory solution is found.

```{r base-lex-ord-ssf-sum}
ssf = filter(base_ssf, Diagnostic == 'ORDERED_EXPLOITATION' & `Selection\nScheme` == 'LEXICASE' & Generations < 60000)
ssf %>%
  group_by(Structure) %>%
  dplyr::summarise(
    count = n(),
    na_cnt = sum(is.na(Generations)),
    min = min(Generations, na.rm = TRUE),
    median = median(Generations, na.rm = TRUE),
    mean = mean(Generations, na.rm = TRUE),
    max = max(Generations, na.rm = TRUE),
    IQR = IQR(Generations, na.rm = TRUE)
  )
```

Kruskal–Wallis test provides evidence of difference among selection schemes.

```{r base-lex-ord-ssf-kru}
kruskal.test(Generations ~ Structure, data = ssf)
```

Results for post-hoc Wilcoxon rank-sum test with a Bonferroni correction.

```{r base-lex-ord-ssf-wil}
pairwise.wilcox.test(x = ssf$Generations, g = ssf$Structure, p.adjust.method = "bonferroni",
                     paired = FALSE, conf.int = FALSE, alternative = 'g')
```